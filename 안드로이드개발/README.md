MVC MVVM MVP AAC

일단 앱을 만들 때 의존성의 문제가 점점 커짐에 따라 유지보수가 점점 어려워지기 때문에 이러한 패턴들이 나왔다.

MVC => 프로그램을 각각의 역할에 따라 Model , View , Controller 로 나누어 설계한 패턴

모든 입력이 Controller로 전달하고 Controller는 입력에 해당하는 Model을 업데이트함
업데이트 결과에따라 View를 선택함 -> Controller는 View를 업데이트 하지않기에 Model과 View사이의 의존성이 발생하게됨.
가장 단순한 패턴이지만 Model과 View사이의 의존성이 발생하는 단점이있어 앱이 커지고 복잡해질수록 유지보수가 어려운 문제가 있다.

MVP => MVC에서 파생된 Model과 View간의 의존성이 없는 아키텍처 패턴

MVC와 달리 입력을 View로 전달하면서 Presenter를 매개체로 view와 model사이를 연결함
View와 Presenter는 1대1 관계이므로 앱이 커질수록 서로 간의 의존성이 커지고 필요한 클래스 개수가 많아짐

MVVM => MVC에서 파생된 것으로 Model과 View의 의존성뿐만 아니라 View와 Conntroller의 의존성도 고려하여 각 구성 요소가 독리적으로 작성되고 테스트 될 수 있도록 설계된 패턴이다. View는 자신이 이용할 ViewModel을 선택해 바인딩하여 업데이트를 받게된다. 
사용자의 입력이 View에 들어옴 -> View는 command 패턴으로 ViewModel에 입력을 전달함 -> ViewModel을 Model에게 데이터를 요청하면 Model은 요청받은 데이터를 응답한다.
View는 ViewModel과 Databinding을 하여 화면에 나타냄.
여러 의존성이 없어져서 좋지만 설계가 쉽지가 않다.














Java의 Collection


1. Set 인터페이스
순서를 유지하지 않는 데이터의 집합으로 데이터의 중복을 허용하지 않는다.

2. List 인터페이스
순서가 있는 데이터의 집합으로 데이터의 중복을 허용한다.

3. Map 인터페이스
키(Key), 값(Value)의 쌍으로 이루어진 데이터으 집합으로,
순서는 유지되지 않으며 키(Key)의 중복을 허용하지 않으나 값(Value)의 중복은 허용한다.












API , REST , REST API , RESTful API

API = 프로그램들이 서로 상호작용하는 것을 도와주는 매개체

REST = 자원을 이름(표현)으로 구분하여 해당 자원의 상태를 주고받는 모든 것을 의미한다.
“웹에 존재하는 모든 자원(이미지, 동영상, DB 자원)에 고유한 URI를 부여해 활용”하는 것으로, 자원을 정의하고 자원에 대한 주소를 지정하는 방법론을 의미한다고 한다.

- 자원: 해당 소프트웨어가 관리하는 모든 것
- 이름: 그 자원을 표현하기 위한 이름 (DB의 학생 정보가 자원이면, ‘students’)
- 상태전달: 데이터가 요청되는 시점에 자원의 상태 (JSON , XML를 통해 데이터를 주고받음)

REST API = REST의 특징을 기반으로 서비스 API를 구현한 것
최근 OpenAPI를 제공하는 기업 대부분은 REST API를 제공한다.
가장 큰 특징으로는 각 요청이 어떤 동작이나 정보를 위한것인지 그 요청의 모습 차체로 추론이 가능하다.

RESTful API = REST의 설계 규칙을 잘 지켜서 설계된 API를 RESTful API라고 한다.





















Hash , Hash알고리즘 , HashMap , HashTable

Hash – 검색과 저장을 아주 빠르게 하는 데이터를 다루는 기법

1. 임의의 크기를 가진 데이터(Key)를 고정된 크기의 데이터(Value)로 변화시켜 저장하는 것
2. 키에 대한 해시 값을 사용하여 값을 저장하고 키-값 쌍의 개수에 따라 동적으로 크기가 증가하는 associate array이다.
3. 키에 대한 해시값을 구하는 과정을 해싱이라고 하며 이때 사용하는 함수를 Hash함수 라고한다.

Hash알고리즘
키에 대한 해시값을 구하는 과정을 해싱이라고 하는데 여기서 Hash함수(알고리즘)이 사용된다.

HashTable
해시 테이블은 (Key, Value)로 데이터를 저장하는 자료구조 중 하나로 빠르게 데이터를 검색할 수 있는 자료구조이다. 내부적으로 버킷을 사용하여 데이터를 저장하기 때문에 빠른 검색속도를 가지고 있다. 각각의 키에 해시함수를 이용해 고유한 index를 생성하고 이 index를통해 값을 저장하거나 검색하기 때문에 엄청ᄈᆞ르다

HashMap과 HashTable의 차이는 동기화 지원 여부이다.
우리는 병렬 처리를 하면서 자원의 동기화를 고려해야 하는 상황이라면 해시테이블(HashTable)을 사용해야 하며, 병렬 처리를 하지 않거나 자원의 동기화를 고려하지 않는 상황이라면 해시맵(HashMap)을 사용하면 된다.
















Process와 Thread의 차이

프로세스는 운영체제로부터 자원을 할당받고 실행되고 있는 프로그램을 의미한다.

쓰레드는 프로세스 내에서 실행되는 흐름의 단위를 의미하고 프로세스 내에 여러개가 생길 수 있다.

멀티프로세스는 하나의 프로그램을 여러개의 프로세스로 구성하여 각 프로세스가 하나의 작업을 처리하도록하여 하나의 프로세스가 잘못되어도 프로그램은 동작하게 만드는 것이다.
컨텍스트스위칭 비용이 발생한다는 단점이있다.

멀티스레드는 하나의 프로세스에 여러 스레드로 자원을 공유하여 작업을 나누어 수행하는 것을 말한다. 멀티프로세스 보다 자원을 효율적으로 관리할 수 있지만 자원을 공유하기 때문에 병목현상이나 데드락같이 동기화문제가 발생할 수 있다.


























안드로이드의 4대 컴포넌트

액티비티 – 화면을 담당하는 컴포넌트

서비스 – 화면에 존재하지 않고 백그라운드에서 실행되는 컴포넌트

브로드캐스트 리시버 – 단말기에서 반응하고 발생하는 다양한 이벤트를 담당하는 컴포넌트

콘텐츠 프로바이더 – 데이터를 저장하고 가져오는 컴포넌트




Activity와 Fragment

Activity – 앱과 사용자가 상호작용을 위한 진입점 역할을 하고 동시에 하나의 UI화면을 그리는 컨테이너 역할을 한다.

Fragment – 다양한 UI를 모듈화하여 재사용하고 화면 구성을 더욱 쉽게 해주도록 도와주는 녀석

Fragment는 Activity안에 정의되어야 한다. (독립적으로 존재할 수 없다.)

둘을 나누는 이유는 뭐에요?
액티비티내에서 프레그먼트는 상대적으로 가볍게 추가/제거가 가능하다. 그렇기 때문에 액티비티 스택에 액티비티를 쌓아두는 것보다 프레그먼트 백스택에서 프레그먼트를 관리하는 것이 메모리 관리면에서도 효율적이며, 화면전환도 액티비티보다 더 순조롭게 할 수 있다.













코틀린의 장점은?

1. Null safety
Nullalbe , Non-nullabale 타입을 따로 지정하여 널체크를 필요없게 만들어줬다.

2. 객체지향 프로그래밍언어이자 함수형 프로그래밍언어이다.
객체지향 프로그래밍은 컴퓨터 프로그램을 명령어의 목록으로 보는 시각에서 벗어나 여러 개의 독립된 단위 즉“객체”들의 모임으로 파악하고자 하는 것이다.
함수형 프로그래밍은 자료 처리를 수학적 함수의 계산으로 취급하고 상태와 가변 데이터를 멀리하는 프로그래밍 패러다임의 하나이다.

3. 실용적이며 간결하다.

4. 고차함수 사용가능 (함수를 인자나 결과값으로 반환받을 수 있음)



자바 vs 코틀린

자바는 함수형프로그래밍 언어가 아니다.
Nullable을 지원하지않는다.
; 를 사용한다.





안드로이드의 Context란?

이름 그대로 해석한다면 애플리케이션(객체)의 현재 상태의 맥락(context)를 의미합니다. 컨텍스트는 새로 생성된 객체가 지금 어떤 일이 일어나고 있는지 알 수 있도록 합니다. 따라서 액티비티와 애플리케이션에 대한 정보를 얻기 위해서는 컨텍스트를 사용하면 됩니다.







클래스와 객체란?

클래스 – 객체를 만들어 내기 위한 설계도 or 틀 (변수와 메서드들의 집합)

객체 – 소프트웨어 세계에 구현할 대상 , 클래스에 선언된 모양 그대로 생성된 실체


다형성(polymorphism)이란?

다형성(polymorphism)이란 하나의 객체가 여러 가지 타입을 가질 수 있는 것을 의미합니다.
자바에서는 이러한 다형성을 부모 클래스 타입의 참조 변수로 자식 클래스 타입의 인스턴스를 참조할 수 있도록 하여 구현하고 있습니다.
다형성은 상속, 추상화와 더불어 객체 지향 프로그래밍을 구성하는 중요한 특징 중 하나입니다.



추상클래스란?

실체클래스의 공통적인 변수나 메서드들을 추출해서 선언한 클래스이다.
1. 추상클래스는 객체를 선언할 수 없다. (아직은 실체성이 없고 구체적이지 않기에)
2. 실체클래스와는 상속관계이다.


인터페이스란?
다른 클래스를 작성할 때 기본이 되는 틀을 제공하면서, 다른 클래스 사이의 중간 매개 역할까지 담당하는 일종의 추상 클래스

자바는 클래스를 이용하여 다중 상속을 할 경우에는 메소드 출처의 모호성 등 여러 가지 문제가 생길 수 있어서 다중 상속을 지원하지 않는다.
근데 다중 상속이 너무 좋으니 이걸 버릴순없으니 인턴페이스라는 것을 만들어서 다중 상속을 지원하고 있다.

자바의 다형성을 극대화하여 개발코드 수정을 줄이고 프로그램 유지보수성을 높이기 위해 사용하는 것



추상클래스 vs 인터페이스
인터페이스는 implements 라는 키워드처럼 인터페이스에 정의된 메소드를 각 클래스의 목적에 맞게 기능을 구현하는 느낌이고, 추상 클래스는 extends 키워드를 사용해서 자신의 기능들을 하위 클래스로 확장 시키는 느낌이라고 생각합니다.




Handler , Looper

일단 핸드러와 루퍼를 사용하는 이유는 안드로이드에서 쓰레드간의 통신을 위해서 사용한다. 이것들을 잘 사용하면 효율적인 멀티 쓰레딩환경을 구축할 수 있다.

Looper - 하나의 쓰레드에는 오직 하나의 Looper 를 가지며, Looper 는 오직 하나의 쓰레드를 담당한다. MessageQueue 에 들어오는 메시지(하나의 작은 작업단위)들을 하나씩 꺼내어 이를 적절한 Handler 로 전달하는 역할을 한다.

Handler - 특정 메세지를 Looper 의 MessageQueue 에 넣거나, Looper 가 MessageQueue 에서 특정 메세지를 꺼내어 전달하면 이를 처리하는 기능을 한다.


이것을 통해서 다른 쓰레드에서 핸들러의 sendMessage()를 통해 메시지를 메인쓰레드 루퍼 의 메시지큐에 넣고 해당 메인쓰레드의 루퍼가 핸들러에게 메시지를 하나씩 전달하고 핸들러가 그 메시지를 처리한다.

핸들러는 항상 루퍼가 필요하다.














액티비티 라이프사이클

1. onCreate() - 앱실행시 불림
2. onStart – Activity가 보이기 전에 불림
3. onResume – Activityt일부가 보일 때 불림
4. onPause – 방해 이벤트 발생시 불림
5. onStop – Activity가 아예안보일 때 불림
6. onRestart – 액티비티가 다시 켜졌을 때 불림
7. onDestroy – 활동이 완전히 종료될떄 불림


Fragment 라이프사이클

1. onAttach() - 프래그먼트가 액티비티에 붙을 때 호출
2. onCreate() - 프래그먼트가 액티비티의 호출을 받아 생성
3. onCreateView() - 레이아웃 inflate 담당 , View와 관련된 객체를 초기화 할 수 있다.
4. onViewCreate() -
onCreagteView()를 통해 반환된 View 객체는 onViewCreated()의 파라미터로 전달 된다. 이 때 Lifecycle이 INITIALIZED 상태로 업데이트가 됨, 그래서 View의 초기값 설정, LiveData 옵저빙, RecyclerView, ViewPager2에 사용될 Adapter 세팅은 이 메소드에서 해주는 것이 적절함

onViewStateRestored() 껴있음

5. onStart() - 사용자에게 보여질 수 있을 때 호출
6. onResume() - Resumed 상태가 됐다는 것은 사용자가 프래그먼트와 상호작용 하기에 적절한 상태 호출
7. onPause() - Fragment가 visible 일 때 onPause()가 호출
8. onStop() - Fragment가 더 이상 화면에 보여지지 않게 되면 onStop() 콜백 호출
9. onDestroyView()
10. onDestroy()
11. onDetach()









ANR
Android 앱의 UI 스레드가 너무 오랫동안 차단되면 'ANR(애플리케이션 응답없음)' 오류가 나타나게 된다.

오래 걸리는 작업이 있다면 서비스로 넘겨서 실행해야 하고, 서비스에서는 다시 백그라운드 스레드를 이용해야 한다.



Retrofit vs OkHttp

Retrofit - Retrofit는 서버와 클라이언트 간 http 통신을 위한 라이브러리이다.

안드로이드 스튜디오에서 네트워크 작업을 할 때 주로 사용하는 대표적인 라이브러리로 OkHttp, Retrofit이 있다.




레이아웃

제약 레이아웃(ConstraintLayout) : 제약 조건을 사용하여 화면을 구성. 안드로이드에서 자동으로 설정하는 디폴트 레이아우이다.

리니어 레이아웃(LinearLayout) : 한 쪽 방향으로 차례대로 뷰를 추가하여 화면을 구성

상대 레이아웃(RelativeLayout) : 부모 컨테이너나 다른 뷰와의 상대적 위치로 화면을 구성

테이블 레이아웃(TableLayout) : 격자 모양의 배열을 사용하여 화면을 구성하는 방법

프레임 레이아웃(FrameLayout) : 가장 상위에 있는 하나의 뷰 또는 뷰그룹만 보여주는 방법. 여러개의 뷰를 중첩한 후 각 뷰를 전환하여 보여주는 방식으로 자주 사용한다.







코틀린의 범위지정 함수

1. let - 자기 자신을 인수로 전달하고 수행된 결과 즉 블록의 마지막 값을 반환
2. run - 익명 함수처럼 사용하는 방법과 객체에서 호출하는 방법을 모두 제공
3. with - 인수로 객체를 받고 블록에 리시버 객체로 전달합니다. 그리고 블록에서 수행된 마지막 결과를 반환합니다
4. apply - 블록에 객체 자신이 리시버 객체로 전달되고 이 객체가 반환됩니다. 객체의 상태를 변화시키고 그 객체를 다시 반환할 때 주로 사용
5. also - 수신 객체 지정 람다에 매개변수 T 로 코드 블록 내에 명시적으로 전달되며 코드 블록 내에 전달된 수신객체를 그대로 다시 반환




lateinit VS by lazy
lateinit – 변수 선언을 먼저하고 초기값 할당을 나중에 하고싶을 때 사용
1. var로 선언한 프로퍼티에만 사용할 수 있다. (val 불가능) 
2. 사용자 정의 getter / setter를 사용하지 않은 프로퍼티에만 사용할 수 있다.
3. null 허용 프로퍼티에는 사용할 수 없다
4. 기초 타입 프로퍼티에는 사용할 수 없다. (Int, Float.. 등등)

by lazy – 값을 지정하는 작업을 미루는 것은 lateinit과 동일하며 할당되는 시점이 변수를 호출하는 시점이다.
1. 호출 시점에 초기화를 진행한다.
2. val 선언한 프로퍼티에만 사용이 가능하다.
3. 클래스 몸체 이외에 최상위 레벨에서 사용이 가능하다.
4. 기초 타입에도 사용이 가능하다.













코틀린에서 중첩클래스와 내부클래스

중첩 클래스는 하나의 클래스가 다른 클래스의 기능과 강하게 연관되어 있다는 의미를 전달하기위해 만들어진 형식으로, 사용할때는 외부클래스의 이름.중첩클래스의 이름 으로 사용하게 된다. 
이때 중첩 클래스 대신 내부 클래스(inner class) 라는것을 사용할 수도 있다.
중첩클래스에 inner 라는 키워드를 붙인 내부 class 는 혼자서는 객체를 만들 수는 없고, 외부 클래스의 객체가 있어야만 생성과 사용이 가능한 클래스이다. 중첩 클래스는 형태만 내부에 존재할 뿐 실질적으로는 내용을 서로 공유할 수 없는 별개의 클래스 이지만 내부 클래스는 외부 클래스 객체 안에서 사용되는 클래스 이므로 외부클래스 객체이 속성이나 함수를 사용 할 수 있다.


싱글톤이란?
싱글톤이란 어떤 클래스가 최초 한번만 메모리를 할당하고 그 메모리에 객체를 만들어 사용하는 디자인 패턴을 말한다.


Companion Object
코틀린에서 자바의 static처럼 사용된다.
하지만 static과는 다르다. companion object는 클래스가 메모리에 적재되면서 함께 생성되는 동반객체이다.



세마포어와 뮤텍스

모두 공유된 자원의 데이터를 여러 스레드/프로세스가 접근하는 것을 막는 역할


데드락
둘 이상의 프로세스들이 자원을 점유한 상태에서 서로 다른 프로세스가 점유하고 있는 자원을 요구하며 무한정 기다리는 현상
조건: 상호배제 , 점유와대기 , 비선점 , 환형 대기
예방법: 예방 , 회피 , 탐지



람다식 이란?

람다식이란 함수명을 선언하고 사용하는 것이 아닌 식별자 없이 실행가능한 함수입니다.
절차형 프로그래밍, 객체지향 프로그래밍과는 사뭇 다르게 함수의 구현과 호출만으로 프로그램을 만드는 방식인 함수형 프로그래밍에서 자주 사용됩니다.

AAC란?
AAC(Android Architecture Components)는 테스트와 유지보수가 쉬운 앱을 디자인할 수 있도록 돕는 라이브러리의 모음입니다.

view model, livedata, room, databinding




MVVM ViewModel VS AAC ViewModel

MVVM의 ViewModel의 역할은 View와 Model 사이에서 데이터를 관리해주고 바인딩 해주는 역할입니다.

AAC의 ViewModel은 화면 회전 같은 환경에서 데이터를 보관하고 라이프사이클을 알고있어서 Activity나 Fragment의 Destroy시 onClear 함수를 통한 데이터 해제의 역할을 하고있습니다.





안드로이드에서의 Manifest

Manifest는 안드로이드 애플리케이션에 대한 각종 정보를 기술한 애플리케이션 명세서이다.








ROOM 이란?
스마트폰 내장 DB에 데이터를 저장하기 위해 사용하는 라이브러리이다.




SharedPreferences 란?
로컬에 데이터를 저장하기 위해서 사용함. - Key-value 방식




백스택이란?
액티비티들은 스택(백스택)에 저장되어 액티비티가 시작되면 스택에 push하고 소멸되면 pop하는 형태이다.






Call By Value vs Call By Reference

call by value 는 가장 일반적인 함수 호출형태로 값을 복사하는 것이다.

Call by reference는 메서드 호출 시에 사용되는 인자가, 값이 아닌 주소(Address)를 넘겨줌으로써, 주소를 참조(Reference)하여 데이터를 변경할 수 있다.






GC는?
가비지 컬렉션(Garbage Collection, GC)은 메모리 관리 기법 중의 하나로, 프로그램이 동적으로 할당했던 메모리 영역 중에서 필요 없게 된 영역을 해제하는 기능이다


프레임워크
프레임워크 - 원하는 기능 구현에 집중하여 개발할 수 있도록 일정한 형태와 필요한 기능을 갖추고 있는 골격, 뼈대를 의미합니다.

안드로이드앱 개발 – Android




라이브러리
라이브러리 - 소프트웨어를 개발할 때 컴퓨터 프로그램이 사용하는 비휘발성 자원의 모임. 즉 특정 기능을 모와둔 코드, 함수들의 집합이며 코드 작성 시 활용 가능한 도구들을 의미합니다.




오버로딩 vs 오버라이딩


오버로딩 - 오버로딩의 정의는 자바의 한 클래스 내에 이미 사용하려는 이름과 같은 이름을 가진 메소드가 있더라도 매개변수의 개수 또는 타입이 다르면, 같은 이름을 사용해서 메소드를 정의할 수 있다.

오버라이딩 - 부모 클래스로부터 상속받은 메소드를 자식 클래스에서 재정의하는 것을 오버라이딩이라고 한다. 상속받은 메소드를 그대로 사용할 수도 있지만, 자식 클래스에서 상황에 맞게 변경해야하는 경우 오버라이딩할 필요가 생긴다.


제네릭이란?

제네릭(Generic)은 직역하자면 '일반적인'이라는 뜻이다. 음.. 한 번에 이해가 가진 않는다. 조금 더 부연설명을 하자면 '데이터 형식에 의존하지 않고, 하나의 값이 여러 다른 데이터 타입들을 가질 수 있도록 하는 방법'이다.



