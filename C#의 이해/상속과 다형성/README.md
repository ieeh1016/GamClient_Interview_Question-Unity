# 상속과 다형성

## 상속성 (Inheritance), 코드 재활용 하기

상속은 기반 클래스(base class)로부터 필드, 메소드 등을 그대로 물려 받아 새로운 파생 클래스(derived class)를 만드는 것이다.

this는 자기자신 객체를 가리키듯이, base는 기반 클래스를 가리킨다.
this() 생성자와 같이 base() 생성자도 마찬가지다. 파생클래스에서 base 키워드를 사용하지 않아도 상속되는 필드, 메소드 등이 노출되지만
(private가 아닐 경우) 명확하게 표현하는 것은 좋은 습관이므로 base 키워드를 사용하는 것을 권한다.

참고로 C#에서는 죽음의 다이아몬드 문제로 클래스에 대한 다중 상속을 지원하지 않는다.

C#에서는 sealed 한정자로 클래스를 작성하게 되면 상속을 봉인할 수 있다. (해당 클래스를 상속할 경우 컴파일 에러가 뜸)

```

sealed class Base{...}
class Derived : base // 컴파일에러
{...}

```

## 다형성(Polymorphism), 오버라이딩을 해보자

다형성은 객체가 여러 형태를 가질 수 있음을 의미합니다.

파생클래스의 인스턴스는 기반클래스의 인스턴스로 사용할 수 있다. 이를 이용하기 위해서는 캐스팅을 해야하는데 C#에서는 안전한 캐스팅 방법으로 다음을 제공한다.

is : 객체가 해당 형식에 해당하는지를 검사하여 그 결과를 bool 값으로 변환한다.
as : 형식 변환 연산자와 같은 역할을 한다. 다만 형변환 연산자가 변환에 실패하는 경우 예외를 던지는 반면에 as연산자는 객체 참조를 null로 만든다.

기반 클래스에 있는 메소드를 파생 클래스에서 사용할 때 다른 기능을 하고 싶다면 오버라이딩(Overriding)을 할 수 있다.
즉 파생 클래스에서 기능이 바뀔 수 있기 때문에 재정의하는 것을 말합니다. 이때 조건은 오버라이딩할 메소드가 virtual 키워드로 되어있어야 한다. (안쓸 경우 컴파일 에러가 발생하므로 이해하고만 있으면 됩니다.)

기반 클래스로 파생클래스를 받아 파생클래스의 오버라이딩된 메서드들을 기반 클래스에서 파생 클래스로 다시 캐스팅할 필요 없이(알아서 객체를 인식하고)호출할 수 있습니다. 단 오버라이딩되지 않은 메서드를 호출하면 기반 클래스에 있는 virtual을 그대로 호출한다.
만약 기반 클래스에 있는 virtual이 구현할 필요가 없는 추상적인 내용이라면 abstract로 만들면 반드시 파생클래스는 오버라이딩하여 구현해야 합니다.

따라서 virtual로 메소드를 정의 한다는 것은 팀프로젝트 단위에서 여러명이서 개발을 진행할 때 이 기반클래스를 상속받아 사용할때 재정의하여 사용하라는 프로그래머의 지시가 될 수 있습니다.

상속을 봉인했던 것처럼 오버라이딩 또한 봉일할 수 있습니다. 파생클래스에서 오버라이딩하여 사용하여 정의하였습니다.
하지만 이 파생클래스를 다시 상속받아 사용할때 오버라이딩을 할 수 없도록 봉인하는 것입니다.

```

class Base
{
	public virtual void SealMe()
	{}
}

class Derived : Base
{
	public sealed override void SealMe()
	{}
}

class DerivedDerived : Derived
{
	public override void SealMe()   // 컴파일 에러
	{}
}


```

봉인 메소드는 파생 클래스의 작성자를 위한 배려입니다. 혹시라도 파생 클래스의 작성자가 오버라이딩 했을 경우 클래스의 다른 부분이 오작동할 가능성이 있습니다.
